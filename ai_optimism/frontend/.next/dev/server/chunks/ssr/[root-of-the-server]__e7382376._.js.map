{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 10, "column": 0}, "map": {"version":3,"sources":["file:///Users/hongyuw2/git-repo/ai-optimism-toolkit/ai_optimism/frontend/src/contexts/AIProviderContext.tsx"],"sourcesContent":["import React, { createContext, useContext, useState, useEffect } from 'react';\nimport type { ReactNode } from 'react';\nimport type { AIProvider } from '../services/ai';\n\nexport type ConnectionStatus = 'disconnected' | 'connecting' | 'connected' | 'error';\n\ninterface AIProviderState {\n    provider: AIProvider | null;\n    model: string | null;\n    apiKey: string | null;\n    endpoint: string | null;\n    status: ConnectionStatus;\n    lastValidated: Date | null;\n    errorMessage: string | null;\n}\n\ninterface AIProviderContextType {\n    state: AIProviderState;\n    connect: (provider: AIProvider, apiKey: string, model: string, endpoint?: string) => Promise<boolean>;\n    disconnect: () => void;\n    isConnected: boolean;\n}\n\nconst AIProviderContext = createContext<AIProviderContextType | undefined>(undefined);\n\nconst STORAGE_KEY = 'ai_provider_config';\n\nexport const AIProviderProvider: React.FC<{ children: ReactNode }> = ({ children }) => {\n    const [state, setState] = useState<AIProviderState>({\n        provider: null,\n        model: null,\n        apiKey: null,\n        endpoint: null,\n        status: 'disconnected',\n        lastValidated: null,\n        errorMessage: null,\n    });\n\n    // Load saved configuration from localStorage on mount\n    useEffect(() => {\n        const loadConfig = () => {\n            const saved = localStorage.getItem(STORAGE_KEY);\n            if (saved) {\n                try {\n                    const config = JSON.parse(saved);\n                    // If we have a saved API key and provider, restore as connected\n                    const hasValidConfig = config.apiKey && config.provider && config.model;\n                    setState(prev => ({\n                        ...prev,\n                        provider: config.provider,\n                        model: config.model,\n                        apiKey: config.apiKey,\n                        endpoint: config.endpoint,\n                        status: hasValidConfig ? 'connected' : 'disconnected',\n                        lastValidated: hasValidConfig ? new Date() : null,\n                    }));\n                    if (hasValidConfig) {\n                        console.log('[AIProvider] Restored connection from localStorage:', {\n                            provider: config.provider,\n                            model: config.model,\n                            hasApiKey: !!config.apiKey\n                        });\n                    }\n                } catch (e) {\n                    console.error('Failed to load saved AI provider config:', e);\n                }\n            } else {\n                // No saved config, ensure disconnected state\n                setState(prev => ({\n                    ...prev,\n                    provider: null,\n                    model: null,\n                    apiKey: null,\n                    endpoint: null,\n                    status: 'disconnected',\n                    lastValidated: null,\n                }));\n            }\n        };\n\n        // Load on mount\n        loadConfig();\n\n        // Listen for storage changes from other tabs/windows\n        const handleStorageChange = (e: StorageEvent) => {\n            if (e.key === STORAGE_KEY) {\n                console.log('[AIProvider] Storage changed in another tab, reloading config');\n                loadConfig();\n            }\n        };\n\n        // Listen for custom event for same-window updates\n        const handleCustomUpdate = () => {\n            console.log('[AIProvider] Config updated in same window, reloading');\n            loadConfig();\n        };\n\n        window.addEventListener('storage', handleStorageChange);\n        window.addEventListener('ai-provider-updated', handleCustomUpdate);\n\n        return () => {\n            window.removeEventListener('storage', handleStorageChange);\n            window.removeEventListener('ai-provider-updated', handleCustomUpdate);\n        };\n    }, []);\n\n    const connect = async (provider: AIProvider, apiKey: string, model: string, endpoint?: string): Promise<boolean> => {\n        // Validate API key is not empty\n        if (!apiKey || apiKey.trim() === '') {\n            setState(prev => ({\n                ...prev,\n                status: 'error',\n                errorMessage: 'API key cannot be empty',\n            }));\n            return false;\n        }\n\n        setState(prev => ({\n            ...prev,\n            status: 'connecting',\n            errorMessage: null,\n        }));\n\n        try {\n            // Test the API key by making a simple request to the chat endpoint\n            console.log('[AIProvider] Testing API key...');\n            const controller = new AbortController();\n            const timeoutId = setTimeout(() => {\n                controller.abort();\n                console.log('[AIProvider] Validation timeout');\n            }, 10000); // 10 second timeout\n\n            const testResponse = await fetch('/api/chat', {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify({\n                    apiKey,\n                    provider,\n                    model,\n                    messages: [{ role: 'user', parts: [{ type: 'text', text: 'Hi' }] }],\n                }),\n                signal: controller.signal,\n            });\n\n            console.log('[AIProvider] Response status:', testResponse.status);\n\n            if (!testResponse.ok) {\n                clearTimeout(timeoutId);\n                const errorData = await testResponse.json().catch(() => ({ error: 'Connection failed' }));\n                console.error('[AIProvider] Response not OK:', errorData);\n                setState(prev => ({\n                    ...prev,\n                    status: 'error',\n                    errorMessage: errorData.error || `HTTP ${testResponse.status}`,\n                }));\n                return false;\n            }\n\n            // For streaming responses, we'll just check that we got a 200 and the response started\n            // Reading the full stream for validation is complex and unnecessary\n            const contentType = testResponse.headers.get('content-type');\n            console.log('[AIProvider] Response content-type:', contentType);\n\n            if (!contentType || !contentType.includes('text')) {\n                clearTimeout(timeoutId);\n                console.error('[AIProvider] Invalid content type:', contentType);\n                setState(prev => ({\n                    ...prev,\n                    status: 'error',\n                    errorMessage: 'Invalid response from server',\n                }));\n                return false;\n            }\n\n            // Response looks good - connection is valid\n            clearTimeout(timeoutId);\n            console.log('[AIProvider] Validation successful!');\n            setState(prev => ({\n                ...prev,\n                provider,\n                apiKey,\n                model,\n                endpoint: endpoint || null,\n                status: 'connected',\n                lastValidated: new Date(),\n                errorMessage: null,\n            }));\n\n            // Save to localStorage for persistence (consider encrypting in production)\n            const config = { provider, apiKey, model, endpoint };\n            localStorage.setItem(STORAGE_KEY, JSON.stringify(config));\n\n            // Dispatch custom event to notify other components in same window\n            window.dispatchEvent(new Event('ai-provider-updated'));\n\n            return true;\n        } catch (error) {\n            const errorMessage = error instanceof Error ? error.message : 'Connection failed';\n            setState(prev => ({\n                ...prev,\n                status: 'error',\n                errorMessage,\n            }));\n            return false;\n        }\n    };\n\n    const disconnect = () => {\n        setState({\n            provider: null,\n            model: null,\n            apiKey: null,\n            endpoint: null,\n            status: 'disconnected',\n            lastValidated: null,\n            errorMessage: null,\n        });\n        localStorage.removeItem(STORAGE_KEY);\n\n        // Dispatch custom event to notify other components in same window\n        window.dispatchEvent(new Event('ai-provider-updated'));\n    };\n\n    const value: AIProviderContextType = {\n        state,\n        connect,\n        disconnect,\n        isConnected: state.status === 'connected',\n    };\n\n    return (\n        <AIProviderContext.Provider value={value}>\n            {children}\n        </AIProviderContext.Provider>\n    );\n};\n\nexport const useAIProvider = (): AIProviderContextType => {\n    const context = useContext(AIProviderContext);\n    if (context === undefined) {\n        throw new Error('useAIProvider must be used within an AIProviderProvider');\n    }\n    return context;\n};\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 242, "column": 0}, "map": {"version":3,"sources":["file:///Users/hongyuw2/git-repo/ai-optimism-toolkit/ai_optimism/frontend/src/lib/emotionCache.ts"],"sourcesContent":["import createCache from '@emotion/cache';\n\nconst isBrowser = typeof document !== 'undefined';\n\n// Create emotion cache for client-side rendering\nexport default function createEmotionCache() {\n  let insertionPoint;\n\n  if (isBrowser) {\n    const emotionInsertionPoint = document.querySelector<HTMLMetaElement>(\n      'meta[name=\"emotion-insertion-point\"]',\n    );\n    insertionPoint = emotionInsertionPoint ?? undefined;\n  }\n\n  return createCache({ key: 'mui-style', insertionPoint });\n}\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,YAAY,OAAO,aAAa;AAGvB,SAAS;IACtB,IAAI;IAEJ,IAAI,WAAW;QACb,MAAM,wBAAwB,SAAS,aAAa,CAClD;QAEF,iBAAiB,yBAAyB;IAC5C;IAEA,OAAO,IAAA,+LAAW,EAAC;QAAE,KAAK;QAAa;IAAe;AACxD"}},
    {"offset": {"line": 264, "column": 0}, "map": {"version":3,"sources":["file:///Users/hongyuw2/git-repo/ai-optimism-toolkit/ai_optimism/frontend/app/providers.tsx"],"sourcesContent":["'use client';\n\nimport { ReactNode, useState } from 'react';\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { CacheProvider } from '@emotion/react';\nimport { AIProviderProvider } from '../src/contexts/AIProviderContext';\nimport createEmotionCache from '../src/lib/emotionCache';\n\n// Create emotion cache on client side\nconst clientSideEmotionCache = createEmotionCache();\n\nexport default function Providers({ children }: { children: ReactNode }) {\n  const [queryClient] = useState(() => new QueryClient());\n  \n  return (\n    <CacheProvider value={clientSideEmotionCache}>\n      <QueryClientProvider client={queryClient}>\n        <AIProviderProvider>\n          {children}\n        </AIProviderProvider>\n      </QueryClientProvider>\n    </CacheProvider>\n  );\n}\n"],"names":[],"mappings":";;;;;AAEA;AACA;AAAA;AACA;AACA;AACA;AANA;;;;;;;AAQA,sCAAsC;AACtC,MAAM,yBAAyB,IAAA,qIAAkB;AAElC,SAAS,UAAU,EAAE,QAAQ,EAA2B;IACrE,MAAM,CAAC,YAAY,GAAG,IAAA,iNAAQ,EAAC,IAAM,IAAI,4LAAW;IAEpD,qBACE,8OAAC,yPAAa;QAAC,OAAO;kBACpB,cAAA,8OAAC,6MAAmB;YAAC,QAAQ;sBAC3B,cAAA,8OAAC,2JAAkB;0BAChB;;;;;;;;;;;;;;;;AAKX"}}]
}