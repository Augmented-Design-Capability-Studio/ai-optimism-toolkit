{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/hongyuw2/git-repo/ai-optimism-toolkit/ai_optimism/frontend/src/contexts/AIProviderContext.tsx"],"sourcesContent":["import React, { createContext, useContext, useState, useEffect } from 'react';\nimport type { ReactNode } from 'react';\nimport type { AIProvider } from '../services/ai';\n\nexport type ConnectionStatus = 'disconnected' | 'connecting' | 'connected' | 'error';\n\ninterface AIProviderState {\n    provider: AIProvider | null;\n    model: string | null;\n    apiKey: string | null;\n    endpoint: string | null;\n    status: ConnectionStatus;\n    lastValidated: Date | null;\n    errorMessage: string | null;\n}\n\ninterface AIProviderContextType {\n    state: AIProviderState;\n    connect: (provider: AIProvider, apiKey: string, model: string, endpoint?: string) => Promise<boolean>;\n    disconnect: () => void;\n    isConnected: boolean;\n}\n\nconst AIProviderContext = createContext<AIProviderContextType | undefined>(undefined);\n\nconst STORAGE_KEY = 'ai_provider_config';\n\nexport const AIProviderProvider: React.FC<{ children: ReactNode }> = ({ children }) => {\n    const [state, setState] = useState<AIProviderState>({\n        provider: null,\n        model: null,\n        apiKey: null,\n        endpoint: null,\n        status: 'disconnected',\n        lastValidated: null,\n        errorMessage: null,\n    });\n\n    // Load saved configuration from localStorage on mount\n    useEffect(() => {\n        const saved = localStorage.getItem(STORAGE_KEY);\n        if (saved) {\n            try {\n                const config = JSON.parse(saved);\n                // If we have a saved API key and provider, restore as connected\n                const hasValidConfig = config.apiKey && config.provider && config.model;\n                setState(prev => ({\n                    ...prev,\n                    provider: config.provider,\n                    model: config.model,\n                    apiKey: config.apiKey,\n                    endpoint: config.endpoint,\n                    status: hasValidConfig ? 'connected' : 'disconnected',\n                    lastValidated: hasValidConfig ? new Date() : null,\n                }));\n                if (hasValidConfig) {\n                    console.log('[AIProvider] Restored connection from localStorage:', {\n                        provider: config.provider,\n                        model: config.model,\n                        hasApiKey: !!config.apiKey\n                    });\n                }\n            } catch (e) {\n                console.error('Failed to load saved AI provider config:', e);\n            }\n        }\n    }, []);\n\n    const connect = async (provider: AIProvider, apiKey: string, model: string, endpoint?: string): Promise<boolean> => {\n        // Validate API key is not empty\n        if (!apiKey || apiKey.trim() === '') {\n            setState(prev => ({\n                ...prev,\n                status: 'error',\n                errorMessage: 'API key cannot be empty',\n            }));\n            return false;\n        }\n\n        setState(prev => ({\n            ...prev,\n            status: 'connecting',\n            errorMessage: null,\n        }));\n\n        try {\n            // Test the API key by making a simple request to the chat endpoint\n            const controller = new AbortController();\n            const timeoutId = setTimeout(() => {\n                controller.abort();\n            }, 10000); // 10 second timeout\n            \n            const testResponse = await fetch('/api/chat', {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify({\n                    apiKey,\n                    provider,\n                    model,\n                    messages: [{ role: 'user', parts: [{ type: 'text', text: 'Hi' }] }],\n                }),\n                signal: controller.signal,\n            });\n\n            if (!testResponse.ok) {\n                clearTimeout(timeoutId);\n                const errorData = await testResponse.json().catch(() => ({ error: 'Connection failed' }));\n                setState(prev => ({\n                    ...prev,\n                    status: 'error',\n                    errorMessage: errorData.error || `HTTP ${testResponse.status}`,\n                }));\n                return false;\n            }\n\n            // For streaming responses, we'll just check that we got a 200\n            const contentType = testResponse.headers.get('content-type');\n            \n            if (!contentType || !contentType.includes('text')) {\n                clearTimeout(timeoutId);\n                setState(prev => ({\n                    ...prev,\n                    status: 'error',\n                    errorMessage: 'Invalid response from server',\n                }));\n                return false;\n            }\n\n            // Response looks good - connection is valid\n            clearTimeout(timeoutId);\n            setState(prev => ({\n                ...prev,\n                provider,\n                apiKey,\n                model,\n                endpoint: endpoint || null,\n                status: 'connected',\n                lastValidated: new Date(),\n                errorMessage: null,\n            }));\n\n            // Save to localStorage for persistence (consider encrypting in production)\n            const config = { provider, apiKey, model, endpoint };\n            localStorage.setItem(STORAGE_KEY, JSON.stringify(config));\n            \n            return true;\n        } catch (error) {\n            const errorMessage = error instanceof Error ? error.message : 'Connection failed';\n            setState(prev => ({\n                ...prev,\n                status: 'error',\n                errorMessage,\n            }));\n            return false;\n        }\n    };\n\n    const disconnect = () => {\n        setState({\n            provider: null,\n            model: null,\n            apiKey: null,\n            endpoint: null,\n            status: 'disconnected',\n            lastValidated: null,\n            errorMessage: null,\n        });\n        localStorage.removeItem(STORAGE_KEY);\n    };\n\n    const value: AIProviderContextType = {\n        state,\n        connect,\n        disconnect,\n        isConnected: state.status === 'connected',\n    };\n\n    return (\n        <AIProviderContext.Provider value={value}>\n            {children}\n        </AIProviderContext.Provider>\n    );\n};\n\nexport const useAIProvider = (): AIProviderContextType => {\n    const context = useContext(AIProviderContext);\n    if (context === undefined) {\n        throw new Error('useAIProvider must be used within an AIProviderProvider');\n    }\n    return context;\n};\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 206, "column": 0}, "map": {"version":3,"sources":["file:///Users/hongyuw2/git-repo/ai-optimism-toolkit/ai_optimism/frontend/src/lib/emotionCache.ts"],"sourcesContent":["import createCache from '@emotion/cache';\n\nconst isBrowser = typeof document !== 'undefined';\n\n// Create emotion cache for client-side rendering\nexport default function createEmotionCache() {\n  let insertionPoint;\n\n  if (isBrowser) {\n    const emotionInsertionPoint = document.querySelector<HTMLMetaElement>(\n      'meta[name=\"emotion-insertion-point\"]',\n    );\n    insertionPoint = emotionInsertionPoint ?? undefined;\n  }\n\n  return createCache({ key: 'mui-style', insertionPoint });\n}\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,YAAY,OAAO,aAAa;AAGvB,SAAS;IACtB,IAAI;IAEJ,IAAI,WAAW;QACb,MAAM,wBAAwB,SAAS,aAAa,CAClD;QAEF,iBAAiB,yBAAyB;IAC5C;IAEA,OAAO,IAAA,6MAAW,EAAC;QAAE,KAAK;QAAa;IAAe;AACxD"}},
    {"offset": {"line": 231, "column": 0}, "map": {"version":3,"sources":["file:///Users/hongyuw2/git-repo/ai-optimism-toolkit/ai_optimism/frontend/app/providers.tsx"],"sourcesContent":["'use client';\n\nimport { ReactNode, useState } from 'react';\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { CacheProvider } from '@emotion/react';\nimport { AIProviderProvider } from '../src/contexts/AIProviderContext';\nimport createEmotionCache from '../src/lib/emotionCache';\n\n// Create emotion cache on client side\nconst clientSideEmotionCache = createEmotionCache();\n\nexport default function Providers({ children }: { children: ReactNode }) {\n  const [queryClient] = useState(() => new QueryClient());\n  \n  return (\n    <CacheProvider value={clientSideEmotionCache}>\n      <QueryClientProvider client={queryClient}>\n        <AIProviderProvider>\n          {children}\n        </AIProviderProvider>\n      </QueryClientProvider>\n    </CacheProvider>\n  );\n}\n"],"names":[],"mappings":";;;;;AAEA;AACA;AAAA;AACA;AACA;AACA;;;AANA;;;;;;AAQA,sCAAsC;AACtC,MAAM,yBAAyB,IAAA,wIAAkB;AAElC,SAAS,UAAU,EAAE,QAAQ,EAA2B;;IACrE,MAAM,CAAC,YAAY,GAAG,IAAA,yKAAQ;8BAAC,IAAM,IAAI,+LAAW;;IAEpD,qBACE,6LAAC,uQAAa;QAAC,OAAO;kBACpB,cAAA,6LAAC,gNAAmB;YAAC,QAAQ;sBAC3B,cAAA,6LAAC,8JAAkB;0BAChB;;;;;;;;;;;;;;;;AAKX;GAZwB;KAAA"}}]
}